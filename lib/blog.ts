import { extract } from "https://deno.land/std@0.145.0/encoding/front_matter.ts";
import * as Marked from "https://esm.sh/marked@4.0.12";

import { join } from "$std/path/mod.ts";

export async function loadFS(dir: string): Promise<Record<string, string>> {
  const files: Record<string, string> = {};
  const loadDir = async (path = "") => {
    const entries = await Deno.readDir(join(dir, path));
    for await (const entry of entries) {
      const entryPath = join(path, entry.name);
      const filePath = join(dir, entryPath);
      if (entry.isDirectory) {
        // Read directory
        await loadDir(entryPath);
      } else {
        // Read file
        files[entryPath] = filePath;
      }
    }
  };
  await loadDir();
  return files;
}

export const buildBlog = async () => {
  const staticContent: Record<string, string> = {};
  const rawContent = await loadFS("./content");
  const content: Record<string, Article> = {};

  for (const pathname in rawContent) {
    if (!pathname.endsWith(".md")) {
      // Store static files in the relative paths
      staticContent[pathname] = rawContent[pathname];
      continue;
    }
    try {
      const contents = await Deno.readFile(rawContent[pathname]);
      const text = new TextDecoder().decode(contents);
      const data = extract<Omit<Article, "url" | "content">>(text);
      const article = { ...data.attrs } as Article;
      article.url = pathname.replace(/(\/index|)\.md$/, "");
      const renderer = new Renderer("/blog" + article.url);
      article.content = await Marked.marked(data.body, { renderer });
      content[article.url] = article;
    } catch (error) {
      error.message = `${error.message} while parsing /content${pathname}`;
      throw error;
    }
  }

  // Write ./content.gen.ts
  const moduleContents = `
// DO NOT EDIT. This file is generated by fresh.
// This file SHOULD be checked into source version control.
// This file is automatically updated during development when running \`dev.ts\`.

export const content:Record<string, Article> = ${JSON.stringify(content)};
export const staticContent:Record<string, string> = ${JSON.stringify(
    staticContent
  )};

export const articlesByPubDate = Object.values(content).sort(
    (a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()
);

export const articlesByTag = Object.values(content).reduce((a, c) => {
    for (const tag of c.tags) {
        if (!(tag in a)) {
            a[tag] = [];
        }
        a[tag].push(c);
        a[tag].sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
    }
    return a;
}, {} as Record<string, Article[]>);
`;
  await Deno.writeFile(
    "./content.gen.ts",
    new TextEncoder().encode(moduleContents)
  );
};

export class Renderer extends Marked.Renderer {
  constructor(private baseUrl: string, options?: Marked.marked.MarkedOptions) {
    super(options);
  }

  link(href: string, title: string, text: string) {
    if (href.startsWith("http")) {
      return `<a href="${href}"${
        title ? ` title="${title}"` : ""
      } rel="noopener noreferrer" target="_blank">${text}</a>`;
    }
    return super.link(href, title, text);
  }

  image(href: string, title: string, text: string): string {
    if (href.startsWith(".")) {
      href = this.baseUrl + href.slice(1);
    }
    return super.image(href, title, text);
  }
}
